//
//  OutputFolder.swift
//  ModelHike
//  https://www.github.com/modelhike/modelhike
//

import Foundation

public protocol PersistableFolder : Actor, SendableDebugStringConvertible, Sendable {
    var foldername: String { get }
    var newFoldername: String { get }
    var outputFolder: OutputFolder? { get }
    func outputFolder(baseFolder: LocalFolder)
    func persist() async throws
}

public actor OutputFolder : SendableDebugStringConvertible {
    internal private(set) var folder: LocalFolder
    public var subFolders: [OutputFolder] = []
    public private(set) var items: [OutputFile] = []
    public private(set) var folderItems: [PersistableFolder] = []
    public var autoGeneratedFileNumber: Int = 1

    public var foldername: String { folder.name }
    public var folderUrl: URL { folder.url }
    public var path: LocalPath { folder.path }

    public func add(_ file: OutputFile) async {
//        if await file.filename.hasSuffix(".env.stage") {
//            await print(file.filename)
//        }
        await file.outputPath( self.folder.path )
        items.append(file)
    }

//    public func add(_ doc: RenderableDocument, to fileSetName: String, renderConfig: RenderConfig) async -> OutputDocumentFile {
//        let folder = await subFolder(fileSetName)
//        return await folder.add(doc, renderConfig: renderConfig)
//    }
//
//    public func add(_ doc: RenderableDocument, filename: String, to fileSetName: String, renderConfig: RenderConfig, type: OutputDocumentFile.InputFileType = .generic) async -> OutputDocumentFile {
//        
//        let folder = await subFolder(fileSetName)
//        return await folder.add(doc, filename: filename, renderConfig: renderConfig, type: type)
//    }
//
//    public func add(_ doc: RenderableDocument, renderConfig: RenderConfig) async -> OutputDocumentFile {
//        let filename = "file\(autoGeneratedFileNumber)"
//        autoGeneratedFileNumber += 1
//        return await add(doc, filename: filename, renderConfig: renderConfig)
//    }
//
//    public func add(_ doc: RenderableDocument, filename: String, renderConfig: RenderConfig, type: OutputDocumentFile.InputFileType = .generic) async -> OutputDocumentFile {
//        let docFile = OutputDocumentFile(doc, filename: filename, renderConfig: renderConfig, type: type)
//        await add( docFile)
//        return docFile
//    }

    public func add(_ subFolder: PersistableFolder) async {
        await subFolder.outputFolder(baseFolder: self.folder)
        self.folderItems.append(subFolder)
    }

    public func add(_ subFolder: OutputFolder) {
        self.subFolders.append(subFolder)
    }
    
    public func persist(with context: GenerationContext) async throws {
        guard items.count > 0 || folderItems.count > 0 || subFolders.count > 0 else {
            return
        }
        
        //create the folder only if any file or sub folder is persisted
        try self.ensureExists()

        for folder in subFolders {
            try await folder.persist(with: context)
            await context.addGenerated(folderPath: folder.path, addFileCount: false)
        }

        for folder in folderItems {
            if let outputFolder = await folder.outputFolder {
                try await folder.persist()
                await context.addGenerated(folderPath: outputFolder.folder)
            }
        }

        for item in items {
            if let outputPath = await item.outputPath {
                await context.addGenerated(filePath: outputPath / item.filename)
                try await item.persist()
            }
        }
    }

    @discardableResult
    public func ensureExists() throws -> Self {
        try self.folder.ensureExists()
        return self
    }

    public func clearFiles() throws {
        try folder.deleteAllFilesAndFolders()
    }

    public var content: OutputFolder { get async { await subFolder("content") }}
    public var pages: OutputFolder { get async { await subFolder("pages") }}
    public var templates: OutputFolder { get async { await subFolder("templates") }}
    public var assets: OutputFolder { get async { await subFolder("assets") }}

    public func relativeFolder(_ itemName: String) async -> OutputFolder {
        //if existing return that sub folder
        for folder in self.subFolders {
            let lastPath = await String(folder.folderUrl.relativePath.suffix(itemName.count))
            if lastPath.is(itemName) {
                return folder
            }
        }

        //else, create a new sub folder, with the relative path
        return createNewRelativeSubFolder(relativePath: itemName)
    }
    
    private func createNewRelativeSubFolder(relativePath: String) -> OutputFolder {
        let folder = LocalFolder(relativePath: relativePath, basePath: self.folder)
        let newSubFolder = OutputFolder(folder)
        self.subFolders.append(newSubFolder)
        return newSubFolder
    }
    
    public func subFolder(_ itemName: String) async -> OutputFolder {
        //if existing return that sub folder
        for folder in self.subFolders {
            if await folder.foldername.is(itemName) {
                return folder
            }
        }

        //else, create a new sub folder
        return createNewSubFolder(name: itemName)
    }

    private func createNewSubFolder(name: String) -> OutputFolder {
        let newSubFolder = OutputFolder(folder.subfolder(at: name))
        self.subFolders.append(newSubFolder)
        return newSubFolder
    }

    public var debugDescription: String { get async {
        return folder.pathString
    }}
    
    public init(_ name: String) {
        self.folder = LocalFolder(path: name)
    }

    public init(_ path: LocalPath) {
        self.folder = LocalFolder(path: path)
    }

    public init(_ folder: LocalFolder) {
        self.folder = folder
    }
}
